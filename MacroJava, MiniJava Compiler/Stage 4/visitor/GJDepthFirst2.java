//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

import javax.security.auth.callback.CallbackHandler;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst2<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R) n.tokenImage; }

   //
   // User-generated visitor methods below
   //

   HashMap<String, HashMap<String, Integer>> labelLine;
   HashMap<String, HashMap<Integer, String>> register;
   HashMap<String, Integer> maxArgCnt;
   HashMap<String, Integer> spilledTemp;
   HashMap<String, HashMap<Integer, Integer>> location;
   public GJDepthFirst2(   HashMap<String, HashMap<String, Integer>>  __labelLine,
                           HashMap<String, HashMap<Integer, String>> __register,
                           HashMap<String, Integer> __maxArgCnt,
                           HashMap<String, Integer> __spilledTemp,
                           HashMap<String, HashMap<Integer, Integer>> __location){
		labelLine = __labelLine;
      register = __register;
      maxArgCnt = __maxArgCnt;
      spilledTemp = __spilledTemp;
      location = __location;
	}
   
   HashMap<String, HashMap<Integer, Integer>> startpoint = new HashMap<>();
   HashMap<String, HashMap<Integer, Integer>> endpoint = new HashMap<>();
   HashMap<String, ArrayList<HashSet<Integer>> > in = new HashMap<>();
   HashMap<String, ArrayList<HashSet<Integer>> > out = new HashMap<>();
   HashMap<String, ArrayList<HashSet<Integer>> > def = new HashMap<>();
   HashMap<String, ArrayList<HashSet<Integer>> > use = new HashMap<>();
   HashMap<String, ArrayList<HashSet<Integer>> > succ = new HashMap<>();
   String procLabel;
   Integer argCnt;
   int counter;
   int stackCtr;

   public void procBegin(){
      counter = 0;
      stackCtr = 0;
      startpoint.put(procLabel, new HashMap<>());
      endpoint.put(procLabel, new HashMap<>());
      in.put(procLabel, new ArrayList<>());
      out.put(procLabel, new ArrayList<>());
      def.put(procLabel, new ArrayList<>());
      use.put(procLabel, new ArrayList<>());
      succ.put(procLabel, new ArrayList<>());
      location.put(procLabel, new HashMap<>());
      register.put(procLabel, new HashMap<>());
      maxArgCnt.put(procLabel, -1);
      for(int i=0; i < Math.min(4, argCnt); i++){
         def.get(procLabel).add(new HashSet<>()); def.get(procLabel).get(i).add(i);
         use.get(procLabel).add(new HashSet<>());
         succ.get(procLabel).add(new HashSet<>()); succ.get(procLabel).get(i).add(i+1);
         counter++;
      }
      for(int i=4; i < argCnt; i++){
         location.get(procLabel).put(i, stackCtr);
         stackCtr++;
      }
   }
   public void procEnd(){
      def.get(procLabel).add(new HashSet<>());
      use.get(procLabel).add(new HashSet<>());
      succ.get(procLabel).add(new HashSet<>());
      counter++;
      // System.out.println(procLabel);
      // System.out.println(labelLine.get(procLabel));
      // System.out.println("DEF = " + def.get(procLabel));
      // System.out.println("USE = " + use.get(procLabel));
      // System.out.println("SUCC = " + succ.get(procLabel));
      liveliness();
      // System.out.println("IN = " + in.get(procLabel));
      // System.out.println("OUT = " + out.get(procLabel));
      getIntervals();
      // System.out.println("START = " + startpoint.get(procLabel));
      // System.out.println("END = " + endpoint.get(procLabel));
      linearScanRA();
      // System.out.println(register.get(procLabel));
      // System.out.println(location.get(procLabel));
      // System.out.println(stackCtr);
      spilledTemp.put(procLabel, stackCtr);
   }
   
   public void liveliness(){
      int n = def.get(procLabel).size();
      for(int i=0; i<n; i++){
         for(int j=4; j<argCnt; j++){
            def.get(procLabel).get(i).remove(j);
            use.get(procLabel).get(i).remove(j);
         }
      }
      
      // REVIEW:
      for(int i=0; i<n; i++){
         for(Integer s: def.get(procLabel).get(i)){
            use.get(procLabel).get(i+1).add(s);
         }
      }
      
      ArrayList<HashSet<Integer>> in1 = in.get(procLabel), out1 = out.get(procLabel), def1 = def.get(procLabel), use1 = use.get(procLabel), succ1 = succ.get(procLabel);
      for(int i=0; i<n; i++){
         in1.add(new HashSet<>());
         out1.add(new HashSet<>());
      }
      HashSet<Integer> in2, out2;
      boolean brk = true;
      do{
         brk = true;
         for(int i=0; i<n; i++){
            in2 = new HashSet<Integer>(in1.get(i));
            out2 = new HashSet<Integer>(out1.get(i));
            HashSet<Integer> temp1 = new HashSet<>(use1.get(i));
            HashSet<Integer> temp2 = new HashSet<>(out1.get(i));
            temp2.removeAll(def1.get(i));
            temp1.addAll(temp2);
            in1.set(i, new HashSet<>(temp1));
            
            HashSet<Integer> temp3 = new HashSet<>();
            for(Integer s: succ1.get(i)){
               temp3.addAll(in1.get(s));
            }
            out1.set(i, temp3);
            if((! in1.get(i).equals(in2)) || (! out1.get(i).equals(out2))) brk = false;
         }
      }while(! brk);
   }
   
   ArrayList<ArrayList<Integer>> intervals = new ArrayList<>();
   public void getIntervals(){
      int n = def.get(procLabel).size();
      for(int i=0; i<n; i++) in.get(procLabel).get(i).addAll(out.get(procLabel).get(i));
      for(int i=0; i<n; i++){
         for(Integer s: in.get(procLabel).get(i)){
            if(!startpoint.get(procLabel).containsKey(s)) startpoint.get(procLabel).put(s, i);
            endpoint.get(procLabel).put(s, i);
         }
      }
      for (Map.Entry<Integer, Integer> e : startpoint.get(procLabel).entrySet()){
         intervals.add(new ArrayList<>());
         int m = intervals.size() - 1;
         intervals.get(m).add(e.getKey());
         intervals.get(m).add(e.getValue());
         intervals.get(m).add(endpoint.get(procLabel).get(e.getKey()));
      }
   }
   ArrayList<ArrayList<Integer>> active = new ArrayList<>();
   ArrayList<String> reg = new ArrayList<>();
   HashSet<String> used = new HashSet<>();
   class SortbyStart implements Comparator<ArrayList<Integer>> {
      public int compare(ArrayList<Integer> a1, ArrayList<Integer> a2) {
         return a1.get(1) - a2.get(1);
      }
   }
   class SortbyEnd implements Comparator<ArrayList<Integer>> {
      public int compare(ArrayList<Integer> a1, ArrayList<Integer> a2) {
         return a1.get(2) - a2.get(2);
      }
   }
   public String getFreeReg(){
      for(String r: reg){
         if(! used.contains(r)) {used.add(r); return r;}
      }
      return "NO REG";
   }
   public void linearScanRA(){
      for(int i=0; i<=7; i++) {reg.add("s"+i);}
      for(int i=0; i<=9; i++) {reg.add("t"+i);}
      int n = intervals.size();
      Collections.sort(intervals, new SortbyStart());
      for(int i=0; i<n; i++){
         expireOldIntervals(intervals.get(i).get(1));
         if(active.size() == reg.size()) spillAtInterval(i);
         else{
            int temp = intervals.get(i).get(0);
            register.get(procLabel).put(temp, getFreeReg());
            active.add(intervals.get(i));
            Collections.sort(active, new SortbyEnd());
         }
      }
      active.clear();intervals.clear();reg.clear();used.clear();
   }
   public void expireOldIntervals(int SPi){
      int n = active.size();
      int cnt = 0;
      for(int j=0; j<n; j++){
         if(active.get(j).get(2) >= SPi){
            for(int k = 0; k < cnt; k++) active.remove(0);
            return;
         }
         cnt++;
         used.remove(register.get(procLabel).get(active.get(j).get(0)));
      }
   }
   public void spillAtInterval(int i){
      int sz = active.size();
      int lastEP = active.get(sz-1).get(2);
      int EPi = intervals.get(i).get(2);
      if(lastEP > EPi){
         String transfer = register.get(procLabel).get(active.get(sz-1).get(0));
         register.get(procLabel).remove(active.get(sz-1).get(0));
         register.get(procLabel).put(intervals.get(i).get(0), transfer);
         location.get(procLabel).put(active.get(sz-1).get(0), stackCtr);
         stackCtr++;
         active.remove(sz-1);
         active.add(intervals.get(i));
         Collections.sort(active, new SortbyEnd());
      }
      else{
         location.get(procLabel).put(intervals.get(i).get(0), stackCtr);
         stackCtr++;
      }
   }
   public int getLineNo(String Label){
      return labelLine.get(procLabel).get(Label);
   }
   
   /** DONE
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      procLabel = "MAIN";
      argCnt = 0;
      procBegin();
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      procEnd();
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /** DONE
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /** DONE
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      procLabel = (String) n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      argCnt = (Integer) n.f2.accept(this, argu);
      procBegin();
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      procEnd();
      return _ret;
   }
   
   /** DONE
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
    public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      def.get(procLabel).add(new HashSet<>());
      use.get(procLabel).add(new HashSet<>());
      succ.get(procLabel).add(new HashSet<>());
      boolean temp = exprCall; exprCall = true;
      n.f3.accept(this, argu);
      exprCall = temp;
      counter++;
      n.f4.accept(this, argu);
      return _ret;
   }

   /** DONE
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      def.get(procLabel).add(new HashSet<>());
      use.get(procLabel).add(new HashSet<>());
      succ.get(procLabel).add(new HashSet<>());
      n.f0.accept(this, argu);
      counter++;
      return _ret;
   }

   /** DONE
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      succ.get(procLabel).get(counter).add(counter + 1);
      return _ret;
   }

   /** DONE
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      succ.get(procLabel).get(counter).add(counter + 1);
      return _ret;
   }

   /** DONE
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer var1 = (Integer) n.f1.accept(this, argu);
      String Label = (String) n.f2.accept(this, argu);
      
      use.get(procLabel).get(counter).add(var1);
      succ.get(procLabel).get(counter).add(counter + 1);
      succ.get(procLabel).get(counter).add(getLineNo(Label));
      return _ret;
   }

   /** DONE
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String Label = (String) n.f1.accept(this, argu);
      succ.get(procLabel).get(counter).add(getLineNo(Label));
      return _ret;
   }

   /** DONE
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer var1 = (Integer) n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      Integer var2 = (Integer) n.f3.accept(this, argu);
      
      succ.get(procLabel).get(counter).add(counter + 1);
      use.get(procLabel).get(counter).add(var1);
      use.get(procLabel).get(counter).add(var2);
      return _ret;
   }

   /** DONE
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer var1 = (Integer) n.f1.accept(this, argu);
      Integer var2 = (Integer) n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      
      succ.get(procLabel).get(counter).add(counter + 1);
      def.get(procLabel).get(counter).add(var1);
      use.get(procLabel).get(counter).add(var2);
      return _ret;
   }

   boolean exprCall = false;
   /** DONE
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer var1 = (Integer) n.f1.accept(this, argu);
      boolean temp = exprCall; exprCall = true;
      n.f2.accept(this, argu);
      exprCall = temp;
      
      def.get(procLabel).get(counter).add(var1);
      succ.get(procLabel).get(counter).add(counter+1);
      return _ret;
   }

   /** DONE
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      boolean temp = exprCall; exprCall = true;
      n.f1.accept(this, argu);
      exprCall = temp;
      succ.get(procLabel).get(counter).add(counter+1);
      return _ret;
   }

   /** DONE
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /** DONE
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   boolean cntArgFlag = false;
   int callArgCnt = 0;
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      cntArgFlag = true; callArgCnt = 0;
      n.f3.accept(this, argu);
      cntArgFlag = false;
      int prev = maxArgCnt.get(procLabel);
      if(prev < callArgCnt) maxArgCnt.put(procLabel, callArgCnt);
      n.f4.accept(this, argu);
      return _ret;
   }

   /** DONE
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /** DONE
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /** DONE
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /** DONE
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      return n.f0.accept(this, argu);
   }

   /** DONE
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      n.f0.accept(this, argu);
      Integer temp = (Integer) n.f1.accept(this, argu);
      if(exprCall) use.get(procLabel).get(counter).add(temp);
      if(cntArgFlag) callArgCnt++;
      return (R) temp;
   }

   /** DONE
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      return (R) Integer.valueOf( (String)n.f0.accept(this, argu));
   }
   
   /** DONE
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      return n.f0.accept(this, argu);
   }
   
}
