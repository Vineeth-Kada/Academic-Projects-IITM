//
// Generated by JTB 1.3.2 (Modified)
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst2<R,A> implements GJVisitor<R,A> {
   
   
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R) n.tokenImage; }
   
	//
	// User-generated visitor methods below
	//
   
   HashMap<String, HashMap<String, ArrayList<String>>> ownFuns;   // Own Functions - Present in the scope of current classe
	HashMap<String, HashMap<String, ArrayList<String>>> allFuns = new HashMap<>();   // All Functions - Present in this class or one of the parent classes
	HashMap<String, HashMap<String, String>> AllGV; // All GV - Variables present in one of the parent classes
	HashMap<String, String> parent;  // parent of current class - default null

   HashMap<String, Boolean> Visited = new HashMap<>();   // Helper variable for consolidating the Functions

	public GJDepthFirst2(
		HashMap<String, HashMap<String, ArrayList<String>>> __ownFuns,
		HashMap<String, HashMap<String, String>> __AllGV,
		HashMap<String, String> __parent
	){
		ownFuns = __ownFuns; AllGV = __AllGV; parent = __parent;
      for (Map.Entry<String, String> e : parent.entrySet()){
         Visited.put(e.getKey(), false);
      }
	}

	public void ERROR(String msg){
      // System.out.println(msg);
      // System.out.println("className: " + className);
      // System.out.println("fun Name: " + funName);
      // // System.out.println("methodName: " + methodName);
      // // System.out.println("methodClass: " + methodClass);
      // System.out.println("ownFuns: " + ownFuns);
      // System.out.println("allFuns: " + allFuns);
      // System.out.println("allGV: " + AllGV);
      // System.out.println("Parent: " + parent);
      // System.out.println("LV: " + LV);
      // System.out.println("FP: " + FP);
		System.out.println("Type error");
		System.exit(0);
	}
   
   public void dbg(String str){
      System.out.println(str);
   }

   public boolean isBasicType(String A){
      return (A.equals("int") || A.equals("int[]") || A.equals("boolean"));
   }
   
   // is arg1 ancestor of arg2 (<=)
   public boolean isAncestor(String A, String B){
      if(isBasicType(B)){
         return B.equals(A);
      }
      String Par = B;
      while(Par != null){
         if(Par.equals(A)) return true;
         Par = parent.get(Par);   
      }
      return false;
   }
   
   // Find least common ancestor
   public String lca(String A, String B){
      if(isBasicType(A) || isBasicType(B)){
         if(A.equals(B)) return A;
         else return null;
      }
      else{
         ArrayList<String> pathA = new ArrayList<>();
         ArrayList<String> pathB = new ArrayList<>();
         String Par = A;
         while(Par != null){
            pathA.add(Par);
            Par = parent.get(Par);
         }
         Collections.reverse(pathA);
         
         Par = B;
         while(Par != null){
            pathB.add(Par);
            Par = parent.get(Par);
         }
         Collections.reverse(pathB);
         
         String __lca = null;
         int n = Math.min(pathA.size(), pathB.size());
         for(int i=0; i<n; i++){
            if(pathA.get(i).equals(pathB.get(i))) __lca = pathA.get(i);
            else break;
         }
         return __lca;
      }
   }
   
   public void gatherAllTill(String className){
      if(! parent.containsKey(className)) ERROR("Gather All Till - Called on a class that doesn't exist");
      if(Visited.get(className)) return;
      String Par = parent.get(className);

      // First copy own functions
      allFuns.put(className, new HashMap<>());
      for (Map.Entry< String, ArrayList<String> > e : ownFuns.get(className).entrySet()){
         allFuns.get(className).put(e.getKey(), e.getValue());
      }
      if(Par == null) return;
      
      Visited.replace(className, true);
      gatherAllTill(Par);

      // Then copy inherited functions
      for(Map.Entry< String, ArrayList<String> > e : allFuns.get(Par).entrySet()){
         if(ownFuns.get(className).containsKey(e.getKey())){
            if(! ownFuns.get(className).get(e.getKey()).equals(e.getValue()))   ERROR("In gather all");
         }
         else allFuns.get(className).put(e.getKey(), e.getValue());
      }
      // Copying Variables
      for(Map.Entry< String, String > e : AllGV.get(Par).entrySet()){
         if(! AllGV.get(className).containsKey(e.getKey())){
            AllGV.get(className).put(e.getKey(), e.getValue());
         } 
      }
   }
   
	int level;
	String className = null;   // Current Class we are dealing with
	String parentClass = null; // Parent of current class
   String funName = null;
   HashMap<String, String> LV = new HashMap<>();   // Local Variables of the function we are dealing
   HashMap<String, String> FP = new HashMap<>();   // FP - Formal Parameters of the function we are dealing with
   HashMap<String, String> GV;                     /* GV - Global variables (Variables in class or parent classes) of the class we are dealing
                                                      Note it is just a pointer to the entry in AllGV which contians GV of all classes */
   String getType = "getType";
   A NULLPTR = null;
   
	/** DONE
	* f0 -> MainClass()
	* f1 -> ( TypeDeclaration() )*
	* f2 -> <EOF>
	*/
	public R visit(Goal n, A argu) {
		R _ret = null;
		n.f0.accept(this, NULLPTR);
		n.f1.accept(this, NULLPTR);
		n.f2.accept(this, NULLPTR);
      System.out.println("Program type checked successfully");
		return _ret;
	}

   /** DONE
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
	public R visit(MainClass n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		n.f1.accept(this, NULLPTR);
		n.f2.accept(this, NULLPTR);
		n.f3.accept(this, NULLPTR);
		n.f4.accept(this, NULLPTR);
		n.f5.accept(this, NULLPTR);
		n.f6.accept(this, NULLPTR);
		n.f7.accept(this, NULLPTR);
		n.f8.accept(this, NULLPTR);
		n.f9.accept(this, NULLPTR);
		n.f10.accept(this, NULLPTR);
		n.f11.accept(this, NULLPTR);
		n.f12.accept(this, NULLPTR);
		n.f13.accept(this, NULLPTR);
		n.f14.accept(this, NULLPTR);
		n.f15.accept(this, NULLPTR);
		n.f16.accept(this, NULLPTR);
		return _ret;
	}

   /** DONE
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
	public R visit(TypeDeclaration n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		return _ret;
	}

   /** DONE      
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
	public R visit(ClassDeclaration n, A argu) {
		R _ret=null;
      level = 0;
		n.f0.accept(this, NULLPTR);
      
		className = (String) n.f1.accept(this, NULLPTR);
      parentClass = null;
      gatherAllTill(className);
      GV = AllGV.get(className);

		n.f2.accept(this, NULLPTR);
		n.f3.accept(this, NULLPTR);
		level = 1;
		n.f4.accept(this, NULLPTR);
		n.f5.accept(this, NULLPTR);
		return _ret;
	}

   /** DONE
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
	public R visit(ClassExtendsDeclaration n, A argu) {
		R _ret=null;
      level = 0;
		n.f0.accept(this, NULLPTR);
      
		className = (String) n.f1.accept(this, NULLPTR);
      gatherAllTill(className);
      GV = AllGV.get(className);
		n.f2.accept(this, NULLPTR);
      
		parentClass = (String) n.f3.accept(this, NULLPTR);
      if(! parent.containsKey(parentClass)) ERROR("Class Extends - Parent class not declared");
		n.f4.accept(this, NULLPTR);
		n.f5.accept(this, NULLPTR);
		level = 1;
		n.f6.accept(this, NULLPTR);
		n.f7.accept(this, NULLPTR);
		return _ret;
	}

   /** DONE
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
	public R visit(VarDeclaration n, A argu) {
		R _ret=null;
		String idType = (String) n.f0.accept(this, NULLPTR);
		String idName = (String) n.f1.accept(this, NULLPTR);
      
      if(level == 1){
         if(LV.containsKey(idName)) ERROR("Var Declaration");
         else{
            LV.put(idName, idType);
         }
      }
      
		n.f2.accept(this, NULLPTR);
		return _ret;
	}

   /** DONE
    * f0 -> AccessType()
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
	public R visit(MethodDeclaration n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		String expReturnType = (String) n.f1.accept(this, NULLPTR);
      funName = (String) n.f2.accept(this, NULLPTR);
		n.f3.accept(this, NULLPTR);
		n.f4.accept(this, NULLPTR);
		n.f5.accept(this, NULLPTR);
		n.f6.accept(this, NULLPTR);
		n.f7.accept(this, NULLPTR);
		n.f8.accept(this, NULLPTR);
		n.f9.accept(this, NULLPTR);
		String actualReturnType = (String) n.f10.accept(this, NULLPTR);
      if(! isAncestor(expReturnType, actualReturnType)) ERROR("Method Decl.");
		n.f11.accept(this, NULLPTR);
		n.f12.accept(this, NULLPTR);
      FP.clear();
      LV.clear();
		return _ret;
	}

	/** DONE
	* f0 -> FormalParameter()
	* f1 -> ( FormalParameterRest() )*
	*/
	public R visit(FormalParameterList n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		n.f1.accept(this, NULLPTR);
		return _ret;
	}

   /** DONE
    * f0 -> Type()
    * f1 -> Identifier()
    */
	public R visit(FormalParameter n, A argu) {
		R _ret=null;
		String idType = (String) n.f0.accept(this, NULLPTR);
		String idName = (String) n.f1.accept(this, NULLPTR);
      if(FP.containsKey(idName)) ERROR("Formal Param");
      else{
         FP.put(idName, idType);
      }
		return _ret;
	}

   /** DONE
    * f0 -> ","
    * f1 -> FormalParameter()
    */
	public R visit(FormalParameterRest n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		n.f1.accept(this, NULLPTR);
		return _ret;
	}

   /** DONE
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
	public R visit(Type n, A argu) {
		String typeName = (String) n.f0.accept(this, NULLPTR);
      if(! isBasicType(typeName)){
         if(! parent.containsKey(typeName)) ERROR("Type - Class doesnt exit");
      }
      return (R) typeName;
	}

   /** DONE
    * f0 -> PublicType()
    *       | PrivateType()
    *       | ProtectedType()
    */
   public R visit(AccessType n, A argu) {
      return n.f0.accept(this, NULLPTR);
   }

   /** DONE
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) {
      n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      n.f2.accept(this, NULLPTR);
      return (R) "int[]";
   }

   /** DONE
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) {
      n.f0.accept(this, NULLPTR);
      return (R) "boolean";
   }

   /** DONE
    * f0 -> "int"
    */
	public R visit(IntegerType n, A argu) {
		n.f0.accept(this, NULLPTR);
		return (R) "int";	
	}

	/** DONE
	* f0 -> "public"
	*/
	public R visit(PublicType n, A argu) {
		n.f0.accept(this, NULLPTR);
		return (R) "public";
	}

   /** DONE
    * f0 -> "private"
    */
   public R visit(PrivateType n, A argu) {
      n.f0.accept(this, NULLPTR);
      return (R) "private";
   }

   /** DONE
    * f0 -> "protected"
    */
   public R visit(ProtectedType n, A argu) {
      n.f0.accept(this, NULLPTR);
      return (R) "protected";
   }

   /** DONE
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n, A argu) {
      R _ret=null;
      n.f0.accept(this, NULLPTR);
      return _ret;
   }

   /** DONE
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {
      R _ret=null;
      n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      n.f2.accept(this, NULLPTR);
      return _ret;
   }

   /** DONE
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
      R _ret=null;
      String LHS = (String) n.f0.accept(this, (A) getType);
      
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      n.f3.accept(this, NULLPTR);
      
      if(isAncestor(LHS, RHS)) return (R) LHS;
      else{
         ERROR("Assgn. Statement");
      }
      return _ret;
   }

   /** DONE
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
      R _ret=null;
      String idType = (String) n.f0.accept(this, (A) getType);
      n.f1.accept(this, NULLPTR);
      String index = (String) n.f2.accept(this, NULLPTR);
      n.f3.accept(this, NULLPTR);
      n.f4.accept(this, NULLPTR);
      String RHS = (String) n.f5.accept(this, NULLPTR);
      n.f6.accept(this, NULLPTR);
      
      if(idType.equals("int[]") && index.equals("int") && RHS.equals("int")) ;
      else ERROR("Array Assgn. Stmt");
      return _ret;
   }

   /** DONE
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, NULLPTR);
      return _ret;
   }

   /** DONE
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String cond = (String) n.f2.accept(this, NULLPTR);
      if(! cond.equals("boolean")) ERROR("If then Stmt");
      n.f3.accept(this, NULLPTR);
      n.f4.accept(this, NULLPTR);
      return _ret;
   }

   /** DONE
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String cond = (String) n.f2.accept(this, NULLPTR);
      if( !cond.equals("boolean")) ERROR("If then Else Stmt");
      n.f3.accept(this, NULLPTR);
      n.f4.accept(this, NULLPTR);
      n.f5.accept(this, NULLPTR);
      n.f6.accept(this, NULLPTR);
      return _ret;
   }

   /** DONE
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String cond = (String) n.f2.accept(this, NULLPTR);
      if(! cond.equals("boolean")) ERROR("While");
      n.f3.accept(this, NULLPTR);
      n.f4.accept(this, NULLPTR);
      return _ret;
   }

   /** DONE
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String cond = (String) n.f2.accept(this, NULLPTR);
      if(!cond.equals("int")) ERROR("Print");
      n.f3.accept(this, NULLPTR);
      n.f4.accept(this, NULLPTR);
      return _ret;
   }

   /** DONE
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | TernaryExpression()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) {
      return n.f0.accept(this, NULLPTR);
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n, A argu) {
      String LHS =  (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      if(LHS.equals(RHS) && LHS.equals("boolean")) return (R) "boolean";
      else ERROR("And");
      return null;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public R visit(OrExpression n, A argu) {
      String LHS =  (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      if(LHS.equals(RHS) && LHS.equals("boolean")) return (R) "boolean";
      else ERROR("or");
      return null;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n, A argu) {
      String LHS =  (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      if(LHS.equals(RHS) && LHS.equals("int")) return (R) "boolean";
      else ERROR("CMP");
      return null;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public R visit(neqExpression n, A argu) {
      String LHS =  (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      if(isAncestor(LHS, RHS) || isAncestor(RHS, LHS)) return (R) "boolean";
      else ERROR("neq");
      return null;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(PlusExpression n, A argu) {
      String LHS =  (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      if(LHS.equals(RHS) && LHS.equals("int")) return (R) "int";
      else ERROR("Plus");
      return null;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n, A argu) {
      String LHS =  (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      if(LHS.equals(RHS) && LHS.equals("int")) return (R) "int";
      else ERROR("Minus");
      return null;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n, A argu) {
      String LHS =  (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      if(LHS.equals(RHS) && LHS.equals("int")) return (R) "int";
      else ERROR("Times");
      return null;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public R visit(DivExpression n, A argu) {
      String LHS =  (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      if(LHS.equals(RHS) && LHS.equals("int")) return (R) "int";
      else ERROR("Div");
      return null;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) {
      R _ret=null;
      String LHS  = (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String RHS = (String) n.f2.accept(this, NULLPTR);
      n.f3.accept(this, NULLPTR);
      if(RHS.equals("int") && LHS.equals("int[]")) return (R) "int";
      else ERROR("Array Lookup");
      return _ret;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) {
      R _ret=null;
      String LHS = (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      n.f2.accept(this, NULLPTR);
      if(LHS.equals("int[]")) return (R) "int";
      else ERROR("Array Len");
      return _ret;
   }

   /** DONE
    * f0 -> PrimaryExpression()
    * f1 -> "?"
    * f2 -> PrimaryExpression()
    * f3 -> ":"
    * f4 -> PrimaryExpression()
    */
    public R visit(TernaryExpression n, A argu) {
      String cond = (String) n.f0.accept(this, NULLPTR);
      n.f1.accept(this, NULLPTR);
      String arg1 = (String) n.f2.accept(this, NULLPTR);
      n.f3.accept(this, NULLPTR);
      String arg2 = (String) n.f4.accept(this, NULLPTR);
      String __lca = lca(arg1, arg2);
      if((!cond.equals("boolean")) ||  __lca == null) ERROR("Ternary");
      return (R) __lca;
   }
   
   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
	public R visit(MessageSend n, A argu) {
      String methodClass = (String) n.f0.accept(this, NULLPTR);
      gatherAllTill(methodClass);
		n.f1.accept(this, NULLPTR);
      String methodName = (String) n.f2.accept(this, NULLPTR);
		n.f3.accept(this, NULLPTR);
      ArrayList<String> exprList = new ArrayList<String>();
		n.f4.accept(this, (A) exprList);
		n.f5.accept(this, NULLPTR);
      
      ArrayList<String> signature = null;
      if(! allFuns.get(methodClass).containsKey(methodName)) ERROR("Message Send - No Method with the given Name");
      else{
         if(ownFuns.get(methodClass).containsKey(methodName)){
            signature = ownFuns.get(methodClass).get(methodName);
         }
         else{
            signature = allFuns.get(methodClass).get(methodName);
            if(signature.get(0).equals("private")) ERROR("Message Send - Private Method - Not Inherited");
         }
      }
      if(exprList.size() + 2 == signature.size()){
         int m = exprList.size();
         for(int i=0; i<m; i++){
            String actual = exprList.get(i);
            String exp = signature.get(i+2);
            if(! isAncestor(exp, actual)) ERROR("Msg Send - Expr List Mismatch");
         }
      }
      else{
         ERROR("Msg Send - Expr List Sizes different");
      }
      
      String methodAccess = signature.get(0);
      if(methodAccess.equals("public"));
      else if(methodAccess.equals("protected") && isAncestor(methodClass, className));
      else if(methodAccess.equals("private") && methodClass.equals(className));
      else ERROR("Msg Send - Access Error");
      
      return (R) signature.get(1);
	}

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n, A argu) {
      R _ret=null;
      ArrayList<String> exprList = (ArrayList<String>) argu;
      exprList.add((String) n.f0.accept(this, NULLPTR));
      n.f1.accept(this, (A) exprList);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n, A argu) {
      R _ret=null;
      ArrayList<String> exprList = (ArrayList<String>) argu;
      n.f0.accept(this, NULLPTR);
      exprList.add((String) n.f1.accept(this, NULLPTR));
      return _ret;
   }

   /** DONE
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n, A argu) {
      return n.f0.accept(this, (A) getType);
   }

   /** DONE
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      n.f0.accept(this, NULLPTR);
      return (R) "int";
   }

   /** DONE
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) {
      n.f0.accept(this, NULLPTR);
      return (R) "boolean";
   }

	/** DONE
	* f0 -> "false"
	*/
	public R visit(FalseLiteral n, A argu) {
		n.f0.accept(this, NULLPTR);
		return (R) "boolean";
	}

	/** DONE
	* f0 -> <IDENTIFIER>
	*/
	public R visit(Identifier n, A argu) {
		String idName = (String) n.f0.accept(this, NULLPTR);
      if(argu != NULLPTR){
         if(LV.containsKey(idName)) return (R) LV.get(idName);
         else if(FP.containsKey(idName)) return (R) FP.get(idName);
         else if(GV.containsKey(idName)) return (R) GV.get(idName);
         else ERROR("Identifier");
         return null;
      }
      else return (R) idName;
	}

	/** DONE
	* f0 -> "this"
	*/
	public R visit(ThisExpression n, A argu) {
		n.f0.accept(this, NULLPTR);
		return (R) className;
	}

   /** DONE
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
	public R visit(ArrayAllocationExpression n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		n.f1.accept(this, NULLPTR);
		n.f2.accept(this, NULLPTR);
		String EXPR = (String) n.f3.accept(this, NULLPTR);
		n.f4.accept(this, NULLPTR);
      if(EXPR.equals("int")) return (R) "int[]";
      else ERROR("Array Alloc Expr");
		return _ret;
	}

   /** DONE
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
	public R visit(AllocationExpression n, A argu) {
		n.f0.accept(this, NULLPTR);
		String LHS = (String) n.f1.accept(this, NULLPTR);
      if(! parent.containsKey(LHS)) ERROR("Alloc Expr - Incorrect Class Name");
		n.f2.accept(this, NULLPTR);
		n.f3.accept(this, NULLPTR);
		return (R) LHS;
	}

   /** DONE
    * f0 -> "!"
    * f1 -> Expression()
    */
	public R visit(NotExpression n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		String LHS = (String) n.f1.accept(this, NULLPTR);
      if(LHS.equals("boolean")) return (R) "boolean";
      else ERROR("Not Expr");
		return _ret;
	}

   /** DONE
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n, A argu) {
      n.f0.accept(this, NULLPTR);
      String LHS = (String) n.f1.accept(this, NULLPTR);
      n.f2.accept(this, NULLPTR);
      return (R) LHS;
   }

   /** WASTE
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
	public R visit(IdentifierList n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		n.f1.accept(this, NULLPTR);
		return _ret;
	}

   /** WASTE
    * f0 -> ","
    * f1 -> Identifier()
    */
	public R visit(IdentifierRest n, A argu) {
		R _ret=null;
		n.f0.accept(this, NULLPTR);
		n.f1.accept(this, NULLPTR);
		return _ret;
	}

}
